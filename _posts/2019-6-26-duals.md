---
layout: post
title: "Deriving Reactive from Imperative: An Introduction to Duals"
permalink: duals
type: engineering
---

While the [debut of Apple’s Combine framework](https://developer.apple.com/videos/play/wwdc2019/722/) didn’t quite take center stage, its implications on our community certainly will for the next decade. We now have a first-party—and unfortunately closed-source[^1]—toolkit for functional reactive programming (often abbreviated with “FRP”) that packs an intimidating [namespace of operators](https://developer.apple.com/documentation/combine/publishers), opaque abstractions such as [Subjects](https://developer.apple.com/documentation/combine/subject) and [Cancellables](https://developer.apple.com/documentation/combine/cancellable), and features even Combine’s open-source counterparts omit like [backpressure](https://developer.apple.com/documentation/combine/subscribers/demand).

> Slide 48 of the intro do combine video with operators

This post aims to unpack those choice adjectives, ‘opaque’ and ‘intimidating,’ that are often lobbed at FRP when folks retreat to its more familiar sibling, imperative programming. We’ll start by contrasting the approaches and covering some history before deriving Combine’s foundational types, `Subscriber` and `Publisher`.

## Imperative and Reactive (er, Declarative)

FRP is a way of handling data flow in declarative a style of computation. At its core, declarative programming focuses on the *what* of our programs, whereas imperative flavorings are focused on *how* to achieve some end, down to the exact commands and control flow. To ground this distinction, here’s an example I often run into while working on [Peloton Digital](https://apps.apple.com/app/apple-store/id792750948), updating an already-rendered cell in response to a member’s action. For instance, when a member takes or deletes a workout, we want to show or hide a checkmark every cell for the corresponding Peloton class.

[`createdWorkout` and `deletedWorkout` notification example leveraging a merge and assign whereas the the imperative approach would have to store state in an extra boolean and then implement a `didSet` to incur the side effect, add a Combine mapConstant operator and use a CancelGroup construction]

## History

Reactive programming has [been around for some time](https://www.cocoawithlove.com/blog/reactive-programming-what-and-why.html#appendix-a-little-bit-of-history). It draws inspiration from “Alan Kay’s 1969 paper [The Reactive Engine](https://www.mprove.de/visionreality/media/kay69.html), [and] modern use of the term ‘reactive programming’ refers to ideas started in Conal Elliot and Paul Hudak’s 1997 paper [Function Reactive Animation](http://conal.net/papers/icfp97/).” However, the paradigm caught wind in late 2009 when Reactive Extensions (Rx) for .NET was released, outlining a specification for other languages to conform to and, by extension (pun intended), join the [Rx family libraries](https://github.com/ReactiveX).

ReactiveCocoa (“RAC,” for short) provided an Objective-C implementation of reactive programming [in May 2012](https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/)—and was ported to Swift in its 3.x release and is now split into two repositories: one [under the same name](https://github.com/ReactiveCocoa/ReactiveCocoa) and the other being [ReactiveSwift](https://github.com/ReactiveCocoa/ReactiveSwift). RxSwift followed suit with its first tagged release landing in May 2015. Comparing the two is [a post in and of itself](https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/), yet, the abstraction behind the implementations is what matters. And sharing that abstraction allows different codebases to [build on the same foundation](https://www.youtube.com/watch?v=_DuGaAkQSnM&t=710).

What explains \(Reactive\|Rx\)Swift being around for at least four years and still not becoming the common tool of choice for building applications? The answer isn’t straightforward—still, we can list a few culprits:

- The frameworks, despite being open-source, are still external dependencies and that’s always a risk to consider when working in Apple’s ecosystem.
- FRP often makes code easier to reason about in the long run, at the cost of a steep on-boarding curve and [having a team of peers who are well-versed and bought into the paradigm](https://twitter.com/chriseidhof/status/1104045586737741826).
- Traditional Computer Science education focuses primarily (if not exclusively) on imperative programming. So, while reactive programming is the other side of the same coin, its incidental complexity is only exacerbated by unfamiliarity.

And, if I were to guess, the unfamiliarity with and months-, if not years-, long patience required to grok FRP keep folks at bay. Helping others climb reactive programming’s learning curve will involve re-thinking educational material on the topic and that’s my goal with the Engineering track of Distillations. Thankfully, reactive programming has roots in mathematics we can rely on and deriving the core types in Combine involves starting with imperative programming and “flipping the arrows,” or as I’ll show, defining its dual.

## Duals

“Dual” is one of those five dollar words for a five cent idea. Chances are you’ve used a dual while writing everyday programs, even if you’re not familiar with the term.

In fact, I’d wager anyone who has been introduced to a mathematical function, i.e. a relation from one set, say `A`, to another, say `B`, in which every member of `A` is associated with exactly one member from `B`, ran into their first dual. If we call such a function `f`, then `A` is its domain and `B` is its range. Or, you might’ve heard `B` called the co-domain—and that “co-” prefix connotes a duality. Rephrased, if we “flipped the arrow” of `f` to instead start from `B` and point towards `A`, then `B` would be our domain.

> Illustration

It’s time to formalize this handy-wavy “flipping of arrows.”

Duals are most easily seen from a category theoretic perspective. Category Theory formalizes the study of structure and composition in terms of its fundamental unit, a category. A category has a few properties:

- It consists of objects. Really, that’s all the detail we get about them and that’s the beauty of it—Category Theory abstracts the details that delineate branches of mathematics to show their similarities.
- There are directed “arrows“ between objects and those arrows must include one for each object to itself (an identity arrow) and must compose associatively. That is, an object, `A`, must have an arrow to itself, and if it has another pointing towards `B` and `B` has one towards `C`, then there exists an arrow from `A` to `C` representing the composition of those two arrows.

> Illustration

And that’s, well, it.

From this construction, Category Theory provides a template for practically all of mathematics. If we consider the objects to be the types in our programs and arrows to be functions between them, then we—[almost](https://ro-che.info/articles/2016-08-07-hask-category)—have a category.

Now we can start clipping arrows. For every construction in category theory, we can reverse all of its arrows to construct its dual. Below is a sketch of defining a tuple of two components in terms of objects and arrows and to its right is the dual, which happens to define [our dear friend, `Either`](https://github.com/pointfreeco/swift-prelude/blob/536b8856e38853854b5c5689e5b5d06da75c992e/Sources/Either/Either.swift#L3-L6).

> Illustration of product and sum types

## Hiding in Plain Sight

With the definition of duals at hand, you start to notice them…everywhere. I’ll point out a few:

### Side Effects and Dependency Injection (Co-Effects)

Any function that returns `Void` either does nothing (simply returning `()`) or performs some side effect on the outside world. Rephrased, side effects are a sort of hidden _output_. Time to flip the function arrow. What is an _input_ from the outside world a function needs to execute (e.g. a shared singleton or the current system time)? Typically, we call this dependency injection—or, with our “co-“ prefix, [they’re co-effects](https://youtu.be/A0VaIKK2ijM?t=394)! 

> labeled snippet

### Predicate Sets and Pullbacks

- Pullback, Brandon’s example of pulling back predicates
    - https://www.pointfree.co/blog/posts/22-some-news-about-contramap

### Key Paths and ??? (Lenses and Prisms)

- Lenses and prisms
	- KeyPaths and the lack of an analog for sum types
	- https://youtu.be/QOIigosUNGU?t=1525

### Structs and Enumerations

- Product and Sum types (and their biases in Swift)
    - lack of anonymous sum types, accessors for enumerations, and Point-Free’s attempt to close that gap

## From `Iterator` and `Sequence` to `Subscriber` and `Publisher`

- push and pull

## Post-Modern Programming

- Moving from “how” to “what.“
- Incorporating the decades (plural) of leanings about structure and composition from Category Theory.
- Stepping off the engineering treadmill and finding stability in mathematics. Functions will (hopefully) never go out of style, and if they do, we’ll have bigger problems to address first.—i.e., re-thinking the entirety of Category Theory, which already refactors practically all of mathematics.

---

## Related Reading and Footnotes

⇒ “[Building up to Combine](https://www.caseyliss.com/2019/6/13/building-up-to-combine)”

⇒ “[Expert to Expert: Brian Beckman and Erik Meijer - Inside the .NET Reactive Framework (Rx)](https://www.youtube.com/watch?v=looJcaeboBY)”

- https://pinboard.in/u:jasdev/t:dual/
- Link to Bartosz’s definition of a dual.
- Link to Swift forums thread asking about an open source Combine
- Rix’s post-modern programming talk, incidental complexity.
- “On Composition”
- What’s next for RAC dual slides
