---
layout: post
title: "Deriving Reactive from Imperative: An Introduction to Duals"
permalink: duals
type: engineering
---

While the [debut of Apple’s Combine framework](https://developer.apple.com/videos/play/wwdc2019/722/) didn’t quite take center stage, its implications on our community certainly will for the next decade. We now have a first-party—and unfortunately closed-source[^1]—toolkit for functional reactive programming (often abbreviated with “FRP”) that packs an intimidating [namespace of operators](https://developer.apple.com/documentation/combine/publishers), opaque abstractions such as [Subjects](https://developer.apple.com/documentation/combine/subject) and [Cancellables](https://developer.apple.com/documentation/combine/cancellable), and features even Combine’s open-source counterparts omit like [backpressure](https://developer.apple.com/documentation/combine/subscribers/demand).

> Slide 48 of the intro do combine video with operators

This post aims to unpack those choice adjectives, ‘opaque’ and ‘intimidating,’ that are often lobbed at FRP when folks retreat to its more familiar sibling, imperative programming. We’ll start by contrasting the approaches and covering some history before deriving Combine’s foundational types, `Subscriber` and `Publisher`.

## Imperative and Reactive (er, Declarative)

FRP is a way of handling data flow in declarative a style of computation. At its core, declarative programming focuses on the *what* of our programs, whereas imperative flavorings are focused on *how* to achieve some end, down to the exact commands and control flow. To ground this distinction, here’s an example I often run into while working on [Peloton Digital](https://apps.apple.com/app/apple-store/id792750948), updating an already-rendered cell in response to a member’s action. For instance, when a member takes or deletes a workout, we want to show or hide a checkmark every cell for the corresponding Peloton class.

[`createdWorkout` and `deletedWorkout` notification example leveraging a merge and assign whereas the the imperative approach would have to store state in an extra boolean and then implement a `didSet` to incur the side effect, add a Combine mapConstant operator and use a CancelGroup construction]

## History

Reactive programming has [been around for some time](https://www.cocoawithlove.com/blog/reactive-programming-what-and-why.html#appendix-a-little-bit-of-history). It draws inspiration from “Alan Kay’s 1969 paper [The Reactive Engine](https://www.mprove.de/visionreality/media/kay69.html), [and] modern use of the term ‘reactive programming’ refers to ideas started in Conal Elliot and Paul Hudak’s 1997 paper [Function Reactive Animation](http://conal.net/papers/icfp97/).” However, the paradigm caught wind in late 2009 when Reactive Extensions (Rx) for .NET was released, outlining a specification for other languages to conform to and, by extension (pun intended), join the [Rx family libraries](https://github.com/ReactiveX).

ReactiveCocoa (“RAC,” for short) provided an Objective-C implementation of reactive programming [in May 2012](https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/)—and was ported to Swift in its 3.x release and is now split into two repositories: one [under the same name](https://github.com/ReactiveCocoa/ReactiveCocoa) and the other being [ReactiveSwift](https://github.com/ReactiveCocoa/ReactiveSwift). RxSwift followed suit with its first tagged release landing in May 2015. Comparing the two is [a post in and of itself](https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/), yet, the abstraction behind the implementations is what matters. And sharing that abstraction allows different codebases to [build on the same foundation](https://www.youtube.com/watch?v=_DuGaAkQSnM&t=710).

What explains \(Reactive\|Rx\)Swift being around for at least four years and still not becoming the common tool of choice for building applications? The answer isn’t straightforward—still, we can list a few culprits:

- The frameworks, despite being open-source, are still external dependencies and that’s always a risk to consider when working in Apple’s ecosystem.
- FRP often makes code easier to reason about in the long run, at the cost of a steep on-boarding curve and [having a team of peers who are well-versed and bought into the paradigm](https://twitter.com/chriseidhof/status/1104045586737741826).
- Traditional Computer Science education focuses primarily (if not exclusively) on imperative programming. So, while reactive programming is the other side of the same coin, its incidental complexity is only exacerbated by unfamiliarity.

And, if I were to guess, the unfamiliarity with and months-, if not years-, long patience required to grok FRP keep folks at bay. Helping others climb reactive programming’s learning curve will involve re-thinking educational material on the topic and that’s my goal with the Engineering track of Distillations. Thankfully, reactive programming has roots in mathematics we can rely on and deriving the core types in Combine involves starting with imperative programming and “flipping the arrows,” or as I’ll show, defining its dual.

## Duals

“Dual” is one of those five dollar words for a five cent idea. Chances are you’ve used a dual while writing everyday programs, even if you’re not familiar with the term.

In fact, I’d wager anyone who has been introduced to a mathematical function, i.e. a relation from one set, say `A`, to another, say `B`, in which every member of `A` is associated with exactly one member from `B`, ran into their first dual. If we call such a function `f`, then `A` is its domain and `B` is its range. Or, you might’ve heard `B` called the co-domain—and that “co-” prefix connotes a duality. Rephrased, if we “flipped the arrow” of `f` to instead start from `B` and point towards `A`, then `B` would be our domain.

> Illustration

It’s time to formalize this handy-wavy “flipping of arrows.”

Duals are most easily seen from a category theoretic perspective. Category Theory formalizes the study of structure and composition in terms of its fundamental unit, a category. A category has a few properties:

- It consists of objects. Really, that’s all the detail we get about them and that’s the beauty of it—Category Theory abstracts the details that delineate branches of mathematics to show their similarities.
- There are directed “arrows“ between objects and those arrows must include one for each object to itself (an identity arrow) and must compose associatively. That is, an object, `A`, must have an arrow to itself, and if it has another pointing towards `B` and `B` has one towards `C`, then there exists an arrow from `A` to `C` representing the composition of those two arrows.

> Illustration

And that’s, well, it.

From this construction, Category Theory provides a template for practically all of mathematics. If we consider the objects to be the types in our programs and arrows to be functions between them, then we—[almost](https://ro-che.info/articles/2016-08-07-hask-category)—have a category.

Now we can start clipping arrows. For every construction in category theory, we can reverse all of its arrows to construct its dual. Below is a sketch of defining a tuple of two components in terms of objects and arrows and to its right is the dual, which happens to define [our dear friend, `Either`](https://github.com/pointfreeco/swift-prelude/blob/536b8856e38853854b5c5689e5b5d06da75c992e/Sources/Either/Either.swift#L3-L6).

> Illustration of product and sum types

## Hiding in Plain Sight

With the definition of duals at hand, you start to notice them…everywhere. I’ll point out a few:

### Side Effects and Dependency Injection (Co-Effects)

Any function that returns `Void` either does nothing (simply returning `()`) or performs some side effect on the outside world. Rephrased, side effects are a sort of hidden _output_. Time to flip the function arrow. What is an _input_ from the outside world a function needs to execute (e.g. a shared singleton or the current system time)? Typically, we call this dependency injection—or, with our “co-“ prefix, [they’re co-effects](https://youtu.be/A0VaIKK2ijM?t=394)! 

> labeled snippet

### Structs and Enumerations

- Product and Sum types (and their biases in Swift)
    - lack of anonymous sum types, accessors for enumerations, and Point-Free’s attempt to close that gap, no prisms

### Key Paths and ??? (Lenses and Prisms)

[SE-0161](https://github.com/apple/swift-evolution/blob/b1caeccf5d273a1cc53b331d41ea169f77294272/proposals/0161-key-paths.md) brought key paths to Swift and with their addition, we can traverse into deeply nested structs (and classes) through a series of properties and subscripts. After a couple of [enhancement](https://github.com/apple/swift-evolution/blob/b1caeccf5d273a1cc53b331d41ea169f77294272/proposals/0249-key-path-literal-function-expressions.md) [proposals](https://github.com/apple/swift-evolution/blob/b1caeccf5d273a1cc53b331d41ea169f77294272/proposals/0227-identity-keypath.md), key paths buy us a sizable chunk of the benefits we’re afforded by a construct more generally called lenses[^2].

_camera pans to Swift’s enumeration type upset in the corner_

Sadly, there’s no first-class affordance for the dual story of traversing into branches of a nested enumeration via associated values, transforming some target value, and gluing the branch back into the enumeration. We have to write these by hand. For our purposes, a prism has two components: a `preview`, in which we attempt to follow a specific branch towards some target value and a `review`, where, given some target associated value, we inject it back into the larger enumeration.

Below is an example representation of `Prism` and how sequence one prism after another:

```swift
struct Prism<A, B> {
	let preview: (A) -> B?
	let review: (B) -> A
}

// Example, maybe `Screen` with an associated `Source`

func combining<A, B, C>(
	_ lhs: Prism<A, B>,
	_ rhs: Prism<B, C>
) -> Prism<A, C> {
	return Prism(
		preview: {
			lhs
				.preview($0)
				.flatMap(rhs.preview)
		},
		review: {
			lhs
				.review(
					rhs.review($0)
				)
		}
	)
}
```

Lens, prisms, and, more generally, optics is a world in and of itself. Here’s a couple of resources:

- Pickering, Gibbons, and Wu’s [Profuctor Optics paper](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf).
- Brandon Williams’ [talk on lenses](https://www.youtube.com/watch?v=ofjehH9f-CU) and [coverage of prisms](https://youtu.be/QOIigosUNGU?t=1525) in his presentation on “Composable Reducers and Effect Systems.”

## From `IteratorProtocol` and `Sequence` to `Subscriber` and `Publisher`

The duals covered—effects and co-effects, products and co-products, and lens and prisms—are primers in seeing the duality between imperative and reactive programming. To start,  here are abbreviated definitions of our dear friends, and fundamental types in the former paradigm, [Iterator](https://developer.apple.com/documentation/swift/iteratorprotocol) and [Sequence](https://developer.apple.com/documentation/swift/sequence):

```swift
protocol IteratorProtocol {
    associatedtype Element

    mutating func next() -> Self.Element?
}

protocol Sequence {
    associatedtype Element where Self.Element == Self.Iterator.Element

    associatedtype Iterator : IteratorProtocol

    func makeIterator() -> Self.Iterator
}
```

At its core, `IteratorProtocol.next` is a function that takes `Void` input and optionally returns an `Iterator.Element`—or rather, “pulling“ from the iterator for the next element.

The dual story is a function that takes an optional `Iterator.Element` and returns `Void`, with the `Void` return (as we touched on earlier) signaling either a no-op or hidden side effects. Now for the two input cases. An `Optional.some(Element)` is akin to receiving the next element of a sequence and an `Optional<Element>.none` is a sort of terminal condition in which the sequence has completed.

Which, conveniently enough, mirror [`Subscriber.receive(_:)`](https://developer.apple.com/documentation/combine/subscriber/3213653-receive) and [`Subscriber.recieve(completion:)`](https://developer.apple.com/documentation/combine/subscriber/3213654-receive), respectively (noting that `Subscriber` also packs the notion of backpressure via [`Subscribers.Demand`](https://developer.apple.com/documentation/combine/subscribers/demand) that isn’t reflected in the duality and error handling through [`Subscribers.Completion.failure(_:)`](https://developer.apple.com/documentation/combine/subscribers/completion/failure) that’s subtly implied by the possibility of `IteratorProtocol.next` crashing at runtime[^].). `Subscriber` is the dual image of `IteratorProtocol` in Apple’s Combine.

Onto `Sequence`. `Sequence.makeIterator` is a function from `Void` to an `IteratorProtocol` and, in the paragraph above, we noted that the core of an iterator is a function from `Void` to `Element?`. Put another way, a `Sequence` has the following shape: `() -> (() -> Element?)`.

“Stop! Dual time.” - MC Hammer

The dual shape is then `(Element? -> ()) -> ()` and substituting `Subscriber` for `Element? -> ()` we get a function that accepts a `Subscriber` and `Void` returns.

And that brings us to [`Publisher.receive(subscriber:)`](https://developer.apple.com/documentation/combine/publisher/3229093-receive)—the attachment point of a subscriber to a publisher.

(Signature overview of duality)

- push and pull
- What’s next for RAC dual slides
- “[Building up to Combine](https://www.caseyliss.com/2019/6/13/building-up-to-combine)”
- “[Expert to Expert: Brian Beckman and Erik Meijer - Inside the .NET Reactive Framework (Rx)](https://www.youtube.com/watch?v=looJcaeboBY)”

## Post-Modern Programming

- Moving from “how” to “what.“
- Incorporating the decades (plural) of leanings about structure and composition from Category Theory.
- Stepping off the engineering treadmill and finding stability in mathematics. Functions will (hopefully) never go out of style, and if they do, we’ll have bigger problems to address first.—i.e., re-thinking the entirety of Category Theory, which already refactors practically all of mathematics.

---

## Related Reading and Footnotes

⇒ 

- https://pinboard.in/u:jasdev/t:dual/
- Link to Bartosz’s definition of a dual.
- Link to Swift forums thread asking about an open source Combine
- Rix’s post-modern programming talk, incidental complexity.
- “On Composition”
- https://github.com/apple/swift-evolution/blob/fe8f41794cb96bfd1942d7b7c1030851cc440ab5/proposals/0102-noreturn-bottom-type.md#never-as-a-universal-bottom-subtype