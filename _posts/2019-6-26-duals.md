---
layout: post
title: "Deriving Reactive from Imperative: An Introduction to Duals"
permalink: duals
type: engineering
---

While the [debut of Apple’s Combine framework](https://developer.apple.com/videos/play/wwdc2019/722/) didn’t quite take center stage, its implications on our community certainly will for the next decade. We now have a first-party—and unfortunately closed-source—toolkit for functional reactive programming (often abbreviated with “FRP”) that packs an intimidating [namespace of operators](https://developer.apple.com/documentation/combine/publishers), opaque abstractions such as [Subjects](https://developer.apple.com/documentation/combine/subject) and [Cancellables](https://developer.apple.com/documentation/combine/cancellable), and features even Combine’s open-source counterparts omit like [backpressure](https://developer.apple.com/documentation/combine/subscribers/demand).

This post aims to unpack those choice adjectives, ‘opaque’ and ‘intimidating,’ that are often lobbed at FRP when folks retreat to its more familiar sibling, imperative programming. We’ll start by contrasting the approaches and covering some history before deriving Combine’s foundational types, `Subscriber` and `Publisher`.

## Imperative and Reactive (er, Declarative)

FRP is a way of handling data flow in declarative a style of computation. At its core, declarative programming focuses on the *what* of our programs, whereas imperative flavorings are focused on *how* to achieve some end, down to the exact commands and control flow. To ground this distinction, here’s an example I often run into while working on [Peloton Digital](https://apps.apple.com/app/apple-store/id792750948), updating an already-rendered cell in response to a member’s action. For instance, when a member takes or deletes a workout, we want to show or hide a checkmark every cell for the corresponding Peloton class.

[`createdWorkout` and `deletedWorkout` notification example leveraging a merge and assign whereas the the imperative approach would have to store state in an extra boolean and then implement a `didSet` to incur the side effect, add a Combine mapConstant operator and use a CancelGroup construction]

diff --git a/Argon.xcodeproj/project.pbxproj b/Argon.xcodeproj/project.pbxproj
index 948723fe4..fddc28784 100644
--- a/Argon.xcodeproj/project.pbxproj
+++ b/Argon.xcodeproj/project.pbxproj
@@ -609,7 +609,6 @@
 		9607504C2280D0F400F31178 /* PelotareTab-0wt.otf in Resources */ = {isa = PBXBuildFile; fileRef = 9607503B2280D0F400F31178 /* PelotareTab-0wt.otf */; };
 		9607504D2280D0F400F31178 /* PelotareTab-400wt.otf in Resources */ = {isa = PBXBuildFile; fileRef = 9607503C2280D0F400F31178 /* PelotareTab-400wt.otf */; };
 		9607504F2284AB4A00F31178 /* BackButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9607504E2284AB4900F31178 /* BackButton.swift */; };
-		9612F179225D35F500E5B8B6 /* ClassGroupDetailsSectionClassCellContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9612F178225D35F500E5B8B6 /* ClassGroupDetailsSectionClassCellContentView.swift */; };
 		9612F17B225D371800E5B8B6 /* ClassGroupDetailsSectionClassCellWithDayLabel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9612F17A225D371800E5B8B6 /* ClassGroupDetailsSectionClassCellWithDayLabel.swift */; };
 		9612F17D22667AB500E5B8B6 /* DependsOnEnglishLocale.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9612F17C22667AB400E5B8B6 /* DependsOnEnglishLocale.swift */; };
 		9647D82B2224761B000FD101 /* Logger.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9647D82A2224761B000FD101 /* Logger.swift */; };
@@ -1083,6 +1082,7 @@
 		BFC18A682204E0F600C8EE2D /* HKWorkout+Safety.m in Sources */ = {isa = PBXBuildFile; fileRef = BFC18A672204E0F600C8EE2D /* HKWorkout+Safety.m */; };
 		BFC18A6A2204E6DD00C8EE2D /* HKSample+Safety.m in Sources */ = {isa = PBXBuildFile; fileRef = BFC18A692204E6DD00C8EE2D /* HKSample+Safety.m */; };
 		BFC335C11F1005D10070F69A /* BrazeHandler.swift in Sources */ = {isa = PBXBuildFile; fileRef = BFC335C01F1005D10070F69A /* BrazeHandler.swift */; };
+		BFC4907622E11AE3008C7F58 /* ClassCellContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = BFC4907522E11AE2008C7F58 /* ClassCellContentView.swift */; };
 		BFC543891E92B35D0006CD00 /* ScheduleManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = BFC543881E92B35D0006CD00 /* ScheduleManager.swift */; };
 		BFC72B221F0FF2B40064623C /* TakeoverViewControllerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = BFC72B211F0FF2B40064623C /* TakeoverViewControllerTests.swift */; };
 		BFC72B251F0FF89B0064623C /* takeoverIconLarge.png in Resources */ = {isa = PBXBuildFile; fileRef = BFC72B231F0FF89B0064623C /* takeoverIconLarge.png */; };
@@ -2142,7 +2142,6 @@
 		9607503B2280D0F400F31178 /* PelotareTab-0wt.otf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "PelotareTab-0wt.otf"; sourceTree = "<group>"; };
 		9607503C2280D0F400F31178 /* PelotareTab-400wt.otf */ = {isa = PBXFileReference; lastKnownFileType = file; path = "PelotareTab-400wt.otf"; sourceTree = "<group>"; };
 		9607504E2284AB4900F31178 /* BackButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BackButton.swift; sourceTree = "<group>"; };
-		9612F178225D35F500E5B8B6 /* ClassGroupDetailsSectionClassCellContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ClassGroupDetailsSectionClassCellContentView.swift; sourceTree = "<group>"; };
 		9612F17A225D371800E5B8B6 /* ClassGroupDetailsSectionClassCellWithDayLabel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ClassGroupDetailsSectionClassCellWithDayLabel.swift; sourceTree = "<group>"; };
 		9612F17C22667AB400E5B8B6 /* DependsOnEnglishLocale.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DependsOnEnglishLocale.swift; sourceTree = "<group>"; };
 		961F353222AAE8EC008F554D /* FundamentalType.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FundamentalType.swift; sourceTree = "<group>"; };
@@ -2629,6 +2628,7 @@
 		BFC18A692204E6DD00C8EE2D /* HKSample+Safety.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = "HKSample+Safety.m"; sourceTree = "<group>"; };
 		BFC18A6B2204E71B00C8EE2D /* HKSample+Safety.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "HKSample+Safety.h"; sourceTree = "<group>"; };
 		BFC335C01F1005D10070F69A /* BrazeHandler.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = BrazeHandler.swift; sourceTree = "<group>"; };
+		BFC4907522E11AE2008C7F58 /* ClassCellContentView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ClassCellContentView.swift; sourceTree = "<group>"; };
 		BFC543881E92B35D0006CD00 /* ScheduleManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ScheduleManager.swift; sourceTree = "<group>"; };
 		BFC72B211F0FF2B40064623C /* TakeoverViewControllerTests.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = TakeoverViewControllerTests.swift; sourceTree = "<group>"; };
 		BFC72B231F0FF89B0064623C /* takeoverIconLarge.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = takeoverIconLarge.png; sourceTree = "<group>"; };
@@ -6611,6 +6611,7 @@
 		EF6E80A5216CFB6700A9F391 /* Views */ = {
 			isa = PBXGroup;
 			children = (
+				BFC4907522E11AE2008C7F58 /* ClassCellContentView.swift */,
 				EF6E80A6216CFDFA00A9F391 /* ClassGroupTabItemView.swift */,
 				EF3F648A2171357300E9FCAB /* ClassGroupCell.swift */,
 				EF83DFF9218215E0007A4410 /* ClassGroupDetailsInstructorCell.swift */,
@@ -6619,7 +6620,6 @@
 				EF96AD6D2188AA9F000A791D /* ClassGroupDetailsSectionTabCell.swift */,
 				EF94FA5B217E3FDA00A945F1 /* ClassGroupDetailsSectionCell.swift */,
 				DACB624E2188CEE500167625 /* ClassGroupDetailsSectionClassCell.swift */,
-				9612F178225D35F500E5B8B6 /* ClassGroupDetailsSectionClassCellContentView.swift */,
 				9612F17A225D371800E5B8B6 /* ClassGroupDetailsSectionClassCellWithDayLabel.swift */,
 			);
 			path = Views;
@@ -7855,7 +7855,6 @@
 				EF604FE521625F6200696AD1 /* IndexTransposer.swift in Sources */,
 				BAFB1F6920C6D73E002E06AB /* PortalCell.swift in Sources */,
 				BACD409C1E9E7EBC00251F25 /* DeviceSelectionNode.swift in Sources */,
-				9612F179225D35F500E5B8B6 /* ClassGroupDetailsSectionClassCellContentView.swift in Sources */,
 				C4232B1B1EF9A56600091B61 /* ShowsNodeLayout.swift in Sources */,
 				C41E1CB31ED59C0E00F43B60 /* FilterSortViewModel.swift in Sources */,
 				BAB7DDFE1D6FA11100B12D92 /* PelotonErrorModel.swift in Sources */,
@@ -7970,6 +7969,7 @@
 				152E3F532149659F0075EBC6 /* FeaturedLiveShowCollectionViewCell.swift in Sources */,
 				15563B17218395650027605E /* ListOrderable.swift in Sources */,
 				C4E5BE491E81A62200956A4F /* ScheduleRouteHandler.swift in Sources */,
+				BFC4907622E11AE3008C7F58 /* ClassCellContentView.swift in Sources */,
 				965640F822D3BFD100E7AD3F /* OnboardingFreeTrialPresenter.swift in Sources */,
 				755A5A4E2124AFFF009340DC /* PlayerCountdownView.swift in Sources */,
 				BA23EF6C214177600034F9F2 /* EndWorkoutClassInfoView.swift in Sources */,
diff --git a/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellContentView.swift b/Argon/Features/Browse/Views/ClassCellContentView.swift
similarity index 81%
rename from Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellContentView.swift
rename to Argon/Features/Browse/Views/ClassCellContentView.swift
index b6cf2e691..52d4ccdf1 100644
--- a/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellContentView.swift
+++ b/Argon/Features/Browse/Views/ClassCellContentView.swift
@@ -11,7 +11,7 @@ import RxSwift
 import UIKit
 
 /// The main content view displayed in Programs cells. This view is composed in a few different cells.
-final class ClassGroupDetailsSectionClassCellContentView: UIView {
+final class ClassCellContentView: UIView {
 	private var disposeBag = DisposeBag()
 	private let gradientView = GradientView().autoLayoutEnabled()
 	private let detailsStackView = UIStackView().autoLayoutEnabled()
@@ -47,7 +47,7 @@ final class ClassGroupDetailsSectionClassCellContentView: UIView {
 		return button
 	}()
 
-	private func bookmarkImage(forBookmarkState isBookmarked: Bool) -> UIImage {
+	private static func bookmarkImage(forBookmarkState isBookmarked: Bool) -> UIImage {
 		let bookmarkIcon = #imageLiteral(resourceName: "show-cell-bookmark-unselected").withRenderingMode(.alwaysOriginal)
 		let bookmarkedIcon = #imageLiteral(resourceName: "show-cell-bookmark-selected").withRenderingMode(.alwaysOriginal)
 
@@ -186,10 +186,59 @@ final class ClassGroupDetailsSectionClassCellContentView: UIView {
 
 		viewModel
 			.bookmarkedObservable
-			.map { [weak self] in
-				self?.bookmarkImage(forBookmarkState: $0)
-			}.bind(to: bookmarkingButton.rx.image(for: .normal))
+			.map { ClassCellContentView.bookmarkImage(forBookmarkState: $0) }
+			.bind(to: bookmarkingButton.rx.image(for: .normal))
 			.disposed(by: disposeBag)
+
+		let matchesCurrentShow: (Notification) -> Bool = {
+			$0.userInfo?["showID"] as? ShowModel.Identifier == viewModel.showID
+		}
+
+		// Noting that in a production scenario, we'd need to remove the returned observer from the center..
+
+		_ = NotificationCenter
+			.default
+			.addObserver(
+				forName: NSNotification.Name("createdBookmark"),
+				object: nil,
+				queue: nil
+			) { [weak self] notification in
+				guard matchesCurrentShow(notification) else { return }
+
+				self?.bookmarkingButton.setImage(
+					ClassCellContentView.bookmarkImage(forBookmarkState: true),
+					for: .normal
+				)
+			}
+
+		_ = NotificationCenter
+			.default
+			.addObserver(
+				forName: NSNotification.Name("deletedBookmark"),
+				object: nil,
+				queue: nil
+			) { [weak self] notification in
+				guard matchesCurrentShow(notification) else { return }
+
+				self?.bookmarkingButton.setImage(
+					ClassCellContentView.bookmarkImage(forBookmarkState: false),
+					for: .normal
+				)
+			}
+
+		Observable.merge(
+			NotificationCenter.default.rx.notification()
+				.observe(.createdBookmark)
+				.filter(matchesCurrentShow)
+				.mapTrue(),
+			AppNotification
+				.observe(.deletedBookmark)
+				.filter(matchesCurrentShow)
+				.mapFalse()
+		)
+		.map(ClassCellContentView.bookmarkImage)
+		.bind(to: bookmarkingButton.rx.image(for: .normal))
+		.disposed(by: disposeBag)
 	}
 
 	/// This view is not itself an accessibility element, but the cells containing it are
diff --git a/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCell.swift b/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCell.swift
index 79700e69d..2cc7d0c33 100644
--- a/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCell.swift
+++ b/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCell.swift
@@ -14,7 +14,7 @@ import UIKit
 /// These cells represent classes which belong to Programs / Collections. This cell wraps a `ClassGroupDetailsSectionClassCellContentView`,
 /// which is shared with `ClassGroupDetailsSectionClassCellWithDayLabel`.
 final class ClassGroupDetailsSectionClassCell: UICollectionViewCell, Reusable {
-	private let classContentView = ClassGroupDetailsSectionClassCellContentView().autoLayoutEnabled()
+	private let classContentView = ClassCellContentView().autoLayoutEnabled()
 
 	override init(frame: CGRect) {
 		super.init(frame: frame)
diff --git a/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellWithDayLabel.swift b/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellWithDayLabel.swift
index 5f4086fcd..acea05770 100644
--- a/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellWithDayLabel.swift
+++ b/Argon/Features/Browse/Views/ClassGroupDetailsSectionClassCellWithDayLabel.swift
@@ -16,7 +16,7 @@ final class ClassGroupDetailsSectionClassCellWithDayLabel: UICollectionViewCell,
 	private var disposeBag = DisposeBag()
 	private let stackView = UIStackView().autoLayoutEnabled()
 	private let dayLabel = UILabel().autoLayoutEnabled()
-	private let classContentView = ClassGroupDetailsSectionClassCellContentView().autoLayoutEnabled()
+	private let classContentView = ClassCellContentView().autoLayoutEnabled()
 
 	override init(frame: CGRect) {
 		super.init(frame: frame)


## History

Reactive programming has [been around for some time](https://www.cocoawithlove.com/blog/reactive-programming-what-and-why.html#appendix-a-little-bit-of-history). It draws inspiration from “Alan Kay’s 1969 paper [The Reactive Engine](https://www.mprove.de/visionreality/media/kay69.html), [and] modern use of the term ‘reactive programming’ refers to ideas started in Conal Elliot and Paul Hudak’s 1997 paper [Function Reactive Animation](http://conal.net/papers/icfp97/).” However, the paradigm caught wind in late 2009 when Reactive Extensions (Rx) for .NET was released, outlining a specification for other languages to conform to and, by extension (pun intended), join the [Rx family libraries](https://github.com/ReactiveX).

ReactiveCocoa (“RAC,” for short) provided an Objective-C implementation of reactive programming [in May 2012](https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/)—and was ported to Swift in its 3.x release and is now split into two repositories: one [under the same name](https://github.com/ReactiveCocoa/ReactiveCocoa) and the other being [ReactiveSwift](https://github.com/ReactiveCocoa/ReactiveSwift). RxSwift followed suit with its first tagged release landing in May 2015. Comparing the two is [a post in and of itself](https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/), yet, the abstraction behind the implementations is what matters. And sharing that abstraction allows different codebases to [build on the same foundation](https://www.youtube.com/watch?v=_DuGaAkQSnM&t=710).

What explains \(Reactive\|Rx\)Swift being around for at least four years and still not becoming the common tool of choice for building applications? The answer isn’t straightforward—still, we can list a few culprits:

- The frameworks, despite being open-source, are still external dependencies and that’s always a risk to consider when working in Apple’s ecosystem.
- FRP often makes code easier to reason about in the long run, at the cost of a steep on-boarding curve and [having a team of peers who are well-versed and bought into the paradigm](https://twitter.com/chriseidhof/status/1104045586737741826).
- Traditional Computer Science education focuses primarily (if not exclusively) on imperative programming. So, while reactive programming is the other side of the same coin, its incidental complexity is only exacerbated by unfamiliarity.

And, if I were to guess, the unfamiliarity with and months-, if not years-, long patience required to grok FRP keep folks at bay. Helping others climb reactive programming’s learning curve will involve re-thinking educational material on the topic and that’s my goal with the Engineering track of Distillations. Thankfully, reactive programming has roots in mathematics we can rely on and deriving the core types in Combine involves starting with imperative programming and “flipping the arrows,” or as I’ll show, defining its dual.

## Duals

“Dual” is one of those five dollar words for a five cent idea. Chances are you’ve used a dual while writing everyday programs, even if you’re not familiar with the term.

In fact, I’d wager anyone who has been introduced to a mathematical function, i.e. a relation from one set, say `A`, to another, say `B`, in which every member of `A` is associated with exactly one member from `B`, ran into their first dual. If we call such a function `f`, then `A` is its domain and `B` is its range. Or, you might’ve heard `B` called the co-domain—and that “co-” prefix connotes a duality. Rephrased, if we “flipped the arrow” of `f` to instead start from `B` and point towards `A`, then `B` would be our domain.

> Illustration

It’s time to formalize this handy-wavy “flipping of arrows.”

Duals are most easily seen from a category theoretic perspective. Category Theory formalizes the study of structure and composition in terms of its fundamental unit, a category. A category has a few properties:

- It consists of objects. Really, that’s all the detail we get about them and that’s the beauty of it—Category Theory abstracts the details that delineate branches of mathematics to show their similarities.
- There are directed “arrows“ between objects and those arrows must include one for each object to itself (an identity arrow) and must compose associatively. That is, an object, `A`, must have an arrow to itself, and if it has another pointing towards `B` and `B` has one towards `C`, then there exists an arrow from `A` to `C` representing the composition of those two arrows.

> Illustration

And that’s, well, it.

From this construction, Category Theory provides a template for practically all of mathematics. If we consider the objects to be the types in our programs and arrows to be functions between them, then we—[almost](https://ro-che.info/articles/2016-08-07-hask-category)—have a category.

Now we can start clipping arrows. For every construction in category theory, we can reverse all of its arrows to construct its dual. Below is a sketch of defining a tuple of two components in terms of objects and arrows and to its right is the dual, which happens to define [our dear friend, `Either`](https://github.com/pointfreeco/swift-prelude/blob/536b8856e38853854b5c5689e5b5d06da75c992e/Sources/Either/Either.swift#L3-L6).

> Illustration of product and sum types

## Hiding in Plain Sight

With the definition of duals at hand, you start to notice them…everywhere. I’ll point out a few:

### Side Effects and Dependency Injection (Co-Effects)

Any function that returns `Void` either does nothing (simply returning `()`) or performs some side effect on the outside world. Rephrased, side effects are a sort of hidden _output_. Time to flip the function arrow. What is an _input_ from the outside world a function needs to execute (e.g. a shared singleton or the current system time)? Typically, we call this dependency injection—or, with our “co-“ prefix, [they’re co-effects](https://youtu.be/A0VaIKK2ijM?t=394)! 

> labeled snippet

### Structs and Enumerations

- Product and Sum types (and their biases in Swift)
    - lack of anonymous sum types, accessors for enumerations, and Point-Free’s attempt to close that gap, no prisms

### Key Paths and ??? (Lenses and Prisms)

[SE-0161](https://github.com/apple/swift-evolution/blob/b1caeccf5d273a1cc53b331d41ea169f77294272/proposals/0161-key-paths.md) brought key paths to Swift and with their addition, we can traverse into deeply nested structs (and classes) through a series of properties and subscripts. After a couple of [enhancement](https://github.com/apple/swift-evolution/blob/b1caeccf5d273a1cc53b331d41ea169f77294272/proposals/0249-key-path-literal-function-expressions.md) [proposals](https://github.com/apple/swift-evolution/blob/b1caeccf5d273a1cc53b331d41ea169f77294272/proposals/0227-identity-keypath.md), key paths buy us a sizable chunk of the benefits we’re afforded by a construct more generally called lenses[^2].

_camera pans to Swift’s enumeration type upset in the corner_

Sadly, there’s no first-class affordance for the dual story of traversing into branches of a nested enumeration via associated values, transforming some target value, and gluing the branch back into the enumeration. We have to write these by hand. For our purposes, a prism has two components: a `preview`, in which we attempt to follow a specific branch towards some target value and a `review`, where, given some target associated value, we inject it back into the larger enumeration.

Below is an example representation of `Prism` and how sequence one prism after another:

```swift
struct Prism<A, B> {
	let preview: (A) -> B?
	let review: (B) -> A
}

// Example, maybe `Screen` with an associated `Source`

func combining<A, B, C>(
	_ lhs: Prism<A, B>,
	_ rhs: Prism<B, C>
) -> Prism<A, C> {
	return Prism(
		preview: {
			lhs
				.preview($0)
				.flatMap(rhs.preview)
		},
		review: {
			lhs
				.review(
					rhs.review($0)
				)
		}
	)
}
```

Lens, prisms, and, more generally, optics is a world in and of itself. Here’s a couple of resources:

- Pickering, Gibbons, and Wu’s [Profuctor Optics paper](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf).
- Brandon Williams’ [talk on lenses](https://www.youtube.com/watch?v=ofjehH9f-CU) and [coverage of prisms](https://youtu.be/QOIigosUNGU?t=1525) in his presentation on “Composable Reducers and Effect Systems.”

## From `IteratorProtocol` and `Sequence` to `Subscriber` and `Publisher`

The duals we’ve covered—effects and co-effects, products and co-products, and lens and prisms—are primers in seeing the duality between imperative and reactive programming. To start,  here are abbreviated definitions of our dear friends, and fundamental imperative types, [Iterator](https://developer.apple.com/documentation/swift/iteratorprotocol) and [Sequence](https://developer.apple.com/documentation/swift/sequence):

```swift
protocol IteratorProtocol {
    associatedtype Element

    mutating func next() -> Self.Element?
}

protocol Sequence {
    associatedtype Element where Self.Element == Self.Iterator.Element

    associatedtype Iterator : IteratorProtocol

    func makeIterator() -> Self.Iterator
}
```

At its core, `IteratorProtocol.next` is a function that takes `Void` input and optionally returns an `IteratorProtocol.Element`—put another way, “pulling“ the next element from the iterator.

The dual story is a function that takes an optional `IteratorProtocol.Element` and returns `Void`, with the `Void` return (as we touched on earlier) signaling either a no-op or hidden side effects. Now for the two input cases. An `Optional.some(Element)` is akin to receiving the next element of a sequence and an `Optional<Element>.none` is a sort of terminal condition when the sequence completes.

Which, conveniently enough, mirror [`Subscriber.receive(_:)`](https://developer.apple.com/documentation/combine/subscriber/3213653-receive) and [`Subscriber.recieve(completion:)`](https://developer.apple.com/documentation/combine/subscriber/3213654-receive), respectively (noting that `Subscriber` also packs the notion of backpressure through [`Subscribers.Demand`](https://developer.apple.com/documentation/combine/subscribers/demand) that isn’t reflected in the duality and error handling through [`Subscribers.Completion.failure(_:)`](https://developer.apple.com/documentation/combine/subscribers/completion/failure) that’s subtly implied by the possibility of `IteratorProtocol.next` crashing at runtime[^].). `Subscriber` is the dual image of `IteratorProtocol` in Apple’s Combine—and instead of “pulling“ `IteratorProtocol.Element`’s, it’s a type that’s “pushed“ [`Subscriber.Input`](https://developer.apple.com/documentation/combine/subscriber/3213652-input)’s

Onto `Sequence`. `Sequence.makeIterator` is a function from `Void` to an `IteratorProtocol` and, in the paragraph above, we noted that an iterator is a function from `Void` to `Element?`. So, `Sequence` has the following shape: `() -> (() -> Element?)`.

“Stop! Dual time.” - MC Hammer

The dual shape is then `(Element? -> ()) -> ()` and substituting `Subscriber` for `Element? -> ()` we get a function that accepts a `Subscriber` and `Void` returns.

And that brings us to [`Publisher.receive(subscriber:)`](https://developer.apple.com/documentation/combine/publisher/3229093-receive)—the attachment point of a subscriber to a publisher.

(Signature overview of duality)

What’s wild about the duality between (`IteratorProtocol`, `Sequence`) and (`Subscriber`, `Publisher`) is that, well, it’s been hiding in plain sight. Apple didn’t cook up a new abstraction—they just flipped the arrows in the same way RAC did as Justin Spahr-Summers explains in [his June 2014 talk on the future of the library](https://youtu.be/ICNjRS2X8WM?t=358), Brian Beckman and Erik Meijer in a [March 2014 Expert to Expert video](https://youtu.be/looJcaeboBY?t=2164), and, most recently, as Casey Liss walked through in his post: “[Building up to Combine](https://www.caseyliss.com/2019/6/13/building-up-to-combine).”

Reactive programming isn’t intrinsically harder (or newer) than imperative—it’s the dual. What requires patience is building an intuition around it in undoing our industry and academic institutions’ bias towards the imperative side of the coin.

I hope this undoing brings us to a period captured by the title of Rob Rix’s 2013 CocoaConf Columbus presentation, [Postmodern Programming](https://github.com/robrix/Postmodern-Programming).

## Postmodern Programming

Rix’s talk is worth multiple reads with multiple coffee, teas or [beverage of choice] and its core is this: declarative programming—and by extension, reactive handling of data flow—allows us to tell our programs “what” to do, instead of meticulously instructing them “how“ to execute. We can then focus on the relationships between components and lean on runtimes and frameworks to determine the mechanics of how those relationships are honored.

“An analytics event should only fire once on view appearance.” As opposed to “we’ll bookkeep that we’ve only fired the event once by adding a boolean to our view and making sure we only flip it, when appropriate.”

“The screen should remove its loading view only when these three API requests have returned successfully” over “here’s three semaphores that signal on each respective API request. Use them to know when to finally remove loading view.”

This isn’t to say post-modern programming will be entirely declarative. There can be times when dualizing the other direction makes code more performant or incurs a smaller memory footprint, if the backing engine isn’t entirely sure how to optimize for a use case.

And that’s okay. If premodern programming leaned imperatively. Then maybe postmodern programming is recognizing the reactive dual and knowing when to be flexible and lean in the other direction.

After all, Combine is just flipping the arrows.

---

## Related Reading and Footnotes

- Link to Bartosz’s definition of a dual.
- https://julesh.com/2017/04/22/on-compositionality/
- https://github.com/apple/swift-evolution/blob/fe8f41794cb96bfd1942d7b7c1030851cc440ab5/proposals/0102-noreturn-bottom-type.md#never-as-a-universal-bottom-subtype