---
layout: post
title: "Deriving Reactive from Imperative: An Introduction to Duals"
permalink: duals
type: engineering
---

While the [debut of Apple’s Combine framework](https://developer.apple.com/videos/play/wwdc2019/722/) didn’t quite take center stage, its implications on our community certainly will for the next decade. We now have a first-party—and unfortunately closed-source[^1]—toolkit for functional reactive programming (often abbreviated with “FRP”) that packs an intimidating [namespace of operators](https://developer.apple.com/documentation/combine/publishers), opaque abstractions such as [Subjects](https://developer.apple.com/documentation/combine/subject) and [Cancellables](https://developer.apple.com/documentation/combine/cancellable), and features even Combine’s open-source counterparts omit like [backpressure](https://developer.apple.com/documentation/combine/subscribers/demand).

> Slide 48 of the intro do combine video with operators

This post aims to unpack those choice adjectives, ‘opaque’ and ‘intimidating,’ that are often lobbed at FRP when folks retreat to its more familiar sibling, imperative programming. Let’s start by contrasting the approaches and covering some history before deriving Combine’s foundational types, `Subscriber` and `Publisher`.

## Imperative and Reactive (er, Declarative)

FRP is a way of handling dataflow in declarative a style of computation. At its core, declarative programming focuses on the *what* of our programs, whereas imperative flavorings are focused on *how* to achieve some end, down to the exact commands and control flow. To ground this distinction, here’s an example I often run into while working on [Peloton Digital](https://apps.apple.com/app/apple-store/id792750948): updating an already-rendered cell in response to a member’s action. For instance, when a member takes or deletes a workout, we want to show or hide a checkmark on the cell for the corresponding Peloton class.

[`createdWorkout` and `deletedWorkout` notification example leveraging a merge and assign whereas the the imperative approach would have to store state in an extra boolean and then implement a `didSet` to incur the side effect, add a Combine mapConstant operator and use a CancelGroup construction]

## History

Reactive programming and has [been around for some time](https://www.cocoawithlove.com/blog/reactive-programming-what-and-why.html#appendix-a-little-bit-of-history). It draws inspiration from “Alan Kay’s 1969 paper [The Reactive Engine](https://www.mprove.de/visionreality/media/kay69.html), [and] modern use of the term ‘reactive programming’ refers to ideas started in Conal Elliot and Paul Hudak’s 1997 paper [Function Reactive Animation](http://conal.net/papers/icfp97/).” However, FRP caught wind in late 2009 when Reactive Extensions (Rx) for .NET was released, outlining a specification for other languages to conform to and, by extension (pun intended), join the [Rx family libraries](https://github.com/ReactiveX).

ReactiveCocoa—now split out into two repositories: one [under the same name](https://github.com/ReactiveCocoa/ReactiveCocoa), “RAC” for short, and the other being [ReactiveSwift](https://github.com/ReactiveCocoa/ReactiveSwift)—provided an Objective-C (and later Swift) implementation of reactive programming [in May 2012](https://github.blog/2012-05-04-reactivecocoa-for-a-better-world/). RxSwift followed suit with its earliest tagged release landing on the same month, three years later in 2015. Comparing the two is [a post in and of itself](https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/), yet, its the abstraction behind the implementation that matter. And sharing the abstraction of FRP what allows teams to [build on the same foundation](https://www.youtube.com/watch?v=_DuGaAkQSnM&t=710).

- Computer science education often covers only one side of the coin.
- Incidental complexity, sharp knife (Eidhof thread )

## Duals

- Introduce the co- phrasing
    - Domain, co-domain
- Light CT introduction

## Hiding in Plain Sight

- Product and Sum types (and their biases in Swift)
    - lack of anonymous sum types, accessors for enumerations, and Point-Free’s attempt to close that gap
- Effects and co-effects
    - Finding joy in FP talk by Brandon
- Pullback, Brandon’s example of pulling back predicates
- Lenses and prisms

## From `Iterator` and `Sequence` to `Subscriber` and `Publisher`

- push and pull

## Post-Modern Programming

- Moving from “how” to “what.“
- Incorporating the decades (plural) of leanings about structure and composition from Category Theory.
- Stepping off the engineering treadmill and finding stability in mathematics. Functions will (hopefully) never go out of style, and if they do, we’ll have bigger problems to address first.—i.e., re-thinking the entirety of Category Theory, which already refactors practically all of mathematics.

---

## Related Reading and Footnotes

⇒ “[Building up to Combine](https://www.caseyliss.com/2019/6/13/building-up-to-combine)”

⇒ “[Expert to Expert: Brian Beckman and Erik Meijer - Inside the .NET Reactive Framework (Rx)](https://www.youtube.com/watch?v=looJcaeboBY)”

- https://pinboard.in/u:jasdev/t:dual/
- Link to Bartosz’s definition of a dual.
- Link to Swift forums thread asking about an open source Combine
- Rix’s post-modern programming talk, incidental complexity.
- “On Composition”
- What’s next for RAC dual slides
