---
layout: post
title: Materialization
permalink: materialization
type: engineering
---

(Assumed audience: folks with some familiarity of Combine’s [`Publisher` contract](https://developer.apple.com/documentation/combine/publisher).)

Materialization, like “[fusion](/fusion-primer)” and “[dual](/duals),” is a seemingly intimidating term for a not-so-intimidating concept.

When I first encountered the word, I thought it was over the top. And it kind of is. This entry tries to bring it down from abstraction and into Swift.

⬦

## <[aliens_guy](https://knowyourmeme.com/memes/ancient-aliens)>Errors as values</aliens_guy>

We’ll often need publishers to drive client-side errors views—which, seem at odds with Combine’s `Publisher` contract:

> [After sending a subscription to a subscriber and they request values,] the publisher is free to send that number of values or fewer to the subscriber.
> 
> …, if the publisher is finite, then it will eventually send a [_single_] completion or an error.

—[WWDC ’19, Session 722 (timestamped transcript)](https://asciiwwdc.com/2019/sessions/722#t=408.346)

Receiving only a single [failure](https://developer.apple.com/documentation/combine/subscribers/completion/failure) (or [finished](https://developer.apple.com/documentation/combine/subscribers/completion/finished)) event makes retrying and displaying error toast views (as an example) difficult. We’d seemingly have to peek into the `‌receiveCompletion` argument of either [`Publisher.handleEvents`](https://developer.apple.com/documentation/combine/publisher/3204713-handleevents) or [`.sink`](https://developer.apple.com/documentation/combine/publisher/3343978-sink) and then re-attach the new publishers generated by retry attempts.

Not ideal.

This not-ideal’ness stems from completion events being _terminal_. There’s sound practical (and theoretical[^1]) reasons for this and we’ll need to bridge the gap by moving our involved `Publisher`’s `Failure` generic _into_ its `Output` type.

“Into” in that sentence is a bit vague. Let’s pause with it.

Publishers emit either `Output`-typed values or `Subscribers.Completion<Failure>` terminating events or some (or none) of the former and a single (or none) of the latter.

So, we have a way of translating any publisher to one in this form (subbing in `AnyPublisher` as a placeholder, for now),

`AnyPublisher<Output, Failure> ⇒ AnyPublisher<Event<Output, Failure>, Never>`.

I’ll need to properly introduce our new friend, `Event`. It’s an enumeration to represent the possible events a subscriber may receive.

<script src="https://gist.github.com/jasdev/5afdb2544530745ea0749e9093dec063.js"></script>

It’s also worth noting our older friend[^2], `Never` prevents the transformed publisher from error’ing out.

This is all sounds nice and well. But, [what’s the point](https://www.pointfree.co/episodes/ep0-we-launched#t92)?

By materializing errors into a publisher’s output, we can then react to them in the same way we would handle ordinary values.

Or, rather, we’re considering our errors as values.

## Two implementations

I skimmed over how the `AnyPublisher<Output, Failure> ⇒ AnyPublisher<Event<Output, Failure>, Never>` transformation works, so let’s fill that in.

We have two options: lean on existing operators or sketch out our own `Publisher` conformance. There’s tradeoffs for each and since there’s [prior art](https://github.com/CombineCommunity/CombineExt/blob/83c71501d41e2f9e6ccc701032c3d6ee0b03c6fc/Sources/Operators/Materialize.swift#L52-L70) for the latter in [CombineCommunity/CombineExt](https://github.com/CombineCommunity/CombineExt), we’ll go with the former.

<script src="https://gist.github.com/jasdev/b334cdb3c79efc50fef555b223df5cdd.js"></script>

Now, we an start chaining operators, case by `Event` case.

Values? We need to box ‘em into `Event.value`.

Leaning on Swift’s generation of static, embedding functions for each case. i.e. `Event.value: (Output) -> Event`.

<script src="https://gist.github.com/jasdev/cf5e768834e68c678585f6c8941d8c59.js"></script>

`Completion.finished`s? Well, we need a way of silencing upstream’s finished event and then turning around and publishing an `Event.completion(.finished)`. Thankfully, the framework ships with a few [`.append(_:)`](https://developer.apple.com/documentation/combine/publisher/3204683-append) overloads.

<script src="https://gist.github.com/jasdev/5e6cbd30c78cbf5a9b5a83e4d822cc82.js"></script>

And lastly, (and densely[^3]), catching error events.

<script src="https://gist.github.com/jasdev/b83638fe55a0ca4aebfa4a689fff71e6.js"></script>

That’s a lot to digest—let’s recap (and maybe take some Tums).

We’re doing three things.

- Lifting emitted values from upstream into the `Event.value` case.
- Intercepting completions with the `append` operator and turning around and sending an `Event.completion(.finished)` to subscribers.
- Catching any `error`s, boxing them up into a `Event.completion(.failure(error))`, and pass it along as a value event.

## Dematerializing

Materializing—in a sort of pseudo-Swift syntax—takes a `Publisher<Output, Failure>` and lifts it to a `Publisher<Event<Output, Failure>, Never>`, shifting errors over to the value side.

However, consumers might only be concerned with specific `Event` cases. Think content views backed by `Output` instances or error views driven by `Failure` values.

We need a way of lowering a previously-materialized sequence, or as [our wise elders](https://github.com/antitypical/Result/blob/c0838342cedfefc25f6dd4f95344d376bed582c7/Result/Result.swift#L84-L88) called it, “dematerializing”

To start, we might be tempted to extend `Publisher` with an `‌Output == Event<Output, Failure>` constraint.

<script src="https://gist.github.com/jasdev/a80b24f64cbc4c90e54d898bae9f02a7.js"></script>

Sadly, the compiler can’t reconcile the recursive constraint. We’ll need to introduce an intermediary protocol, `EventConvertible`, [following Rx’s lead](https://github.com/ReactiveX/RxSwift/blob/9b31a15520306b073cb9d46456f64826c1d6dcab/RxSwift/Event.swift#L92-L109).

<script src="https://gist.github.com/jasdev/67dd1174dcc42cb7a18dcb1831451ef5.js"></script>

In both `values` and `errors` we’ll wanna focus in on upstream `Event.value` and `.completion(.failure(_))`s, respectively. There’s a few ways we could go about doing this—e.g. filtering out other cases or compacting associated values à la Point-Free’s [enumeration properties](https://www.pointfree.co/episodes/ep52-enum-properties).

The latter route is more fun—still, the former is as equally valid.



## “All together now (materializing and dematerializing)” — The Beatles, I think.

- Etymology
- Prior art from `Result`
- https://github.com/antitypical/Result/blob/c0838342cedfefc25f6dd4f95344d376bed582c7/Result/Result.swift#L228-L236
- Rx and ReactiveSwift’s Action
	- https://github.com/ReactiveCocoa/ReactiveSwift/blob/e27ccdbf4ec36f154b60b91a0d7e0110c4e882cb/Documentation/FrameworkOverview.md#actions
	- https://github.com/RxSwiftCommunity/Action
	- There’s a gap here that we’ll likely need to fill in over at `CombineCommunity`

■

---

## Footnotes and related reading

[^1]: I’ll have some more writing on this, soon. Until then, Brian Beckman and Erik Meijer’s [’09 Expert to Expert session](https://www.youtube.com/watch?v=looJcaeboBY) is worth the time.

[^2]: No fret if you’re meeting `Never` for the first time. The NSHipster folks have [a fantastic entry](https://nshipster.com/never/) on the type.

[^3]: If you’re open to operators, importing a Prelude of choice can rework the `catch` to [this form](https://gist.github.com/jasdev/2158a4605cf0d9df377a7602cc81a5ea).

⇒ 